package toneshell

import (
    "os"
    "path/filepath"
    "testing"

    "evals.mitre.org/control_server/config"
    "evals.mitre.org/control_server/handlers/handler_util"
    "evals.mitre.org/control_server/restapi/restapi_test_util"
    "evals.mitre.org/control_server/sessions"
    "evals.mitre.org/control_server/util"
    "evals.mitre.org/control_server/util/test_util"
    "evals.mitre.org/control_server/util/test_util/assert_util"
)

const (
    REST_API_LISTEN_HOST = "127.0.0.1:10008"
)

var (
    TEST_SESSION_ID   = "ce03834430fcccbe541ccc5bf46cb1f2"
    PAYLOAD_TEST_DIR  = filepath.Join(util.ProjectRoot, "test_payloads")
    PAYLOAD_TEST_DIRS = map[string]string{HANDLER_NAME: PAYLOAD_TEST_DIR}
    DUMMY_KEY         = []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
    DUMMY_XOR_KEY     = []byte{0x58, 0x4f, 0x52, 0x4b, 0x45, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

    TEST_TASK                   = "{\"id\": 5, \"taskNum\": 1, \"args\":\"whoami\"}"
    TEST_FILE_DOWNLOAD_TASK     = "{\"id\": 3, \"taskNum\": 1, \"args\":\"C:\\\\Users\\\\Public\\\\test.txt\", \"payload\": \"examplepayload.txt\"}"
    TEST_TASK_RESPONSE          = []byte{0x18, 0x04, 0x04, 0x13, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x77, 0x68, 0x6f, 0x61, 0x6d, 0x69}
    TEST_RC4_TASK_RESPONSE      = []byte{0x18, 0x04, 0x04, 0x13, 0x00, 0xdb, 0x19, 0x89, 0x41, 0xa3, 0x4f, 0x5d, 0x3a, 0x8a, 0x00, 0x1e, 0x67, 0x57, 0x19, 0xfa, 0x02, 0xa6, 0x77, 0x16}
    TEST_HANDSHAKE_RESPONSE     = []byte{0x18, 0x04, 0x04, 0x02, 0x00, 0x08, 0x08}
    TEST_RC4_HANDSHAKE_RESPONSE = []byte{0x18, 0x04, 0x04, 0x02, 0x00, 0xd6, 0x10}
    TEST_HANDSHAKE_PACKET       = []byte{0x18, 0x04, 0x04, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x0a, 0x00, 0x00, 0x00, 0x6d, 0x79, 0x48, 0x6f, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65}
    TEST_RC4_HANDSHAKE_PACKET   = []byte{0x18, 0x04, 0x04, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdf, 0x19, 0x88, 0x40, 0xa2, 0x36, 0x5c, 0x3b, 0x8b, 0x07, 0x1f, 0x66, 0x56, 0x6f, 0x93, 0x6c, 0xc6, 0x10, 0x7f, 0xa3, 0xf0, 0xa1, 0x92, 0xdf, 0x2a, 0x58, 0x39, 0x7c, 0x46, 0xfb, 0x3a}
    TEST_XOR_HANDSHAKE_PACKET   = []byte{0x18, 0x04, 0x04, 0x1F, 0x00, 0x58, 0x4f, 0x52, 0x4b, 0x45, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x4e, 0x53, 0x4a, 0x44, 0x58, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x0a, 0x00, 0x00, 0x00, 0x6d, 0x79, 0x48, 0x6f, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65}
    TEST_INVALID_PACKET         = []byte{0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x6d, 0x79, 0x48, 0x6f, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65}
    TEST_FILE_CHUNK_1           = []byte{0x18, 0x04, 0x04, 0x09, 0x00, 0x06, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20}
    TEST_FILE_CHUNK_2           = []byte{0x18, 0x04, 0x04, 0x08, 0x00, 0x06, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64}
    TEST_FILE_UPLOAD_CONTENTS   = []byte("test upload file contents")
    TEST_FILE_UPLOAD_NAME       = "test_upload.txt"
    TEST_UPLOAD_HASH            = "09347adcaffed3c23290b3b5a07a8a36"
    TEST_FILE_UPLOAD_TASK       = "{\"id\": 7, \"taskNum\": 1, \"args\":\"C:\\\\Users\\\\Public\\\\test.txt\", \"fileName\": \"test_upload.txt\"}"
)

var testConfigEntry = config.HandlerConfigEntry{
    "host":       "127.0.0.1",
    "port":       10005,
    "payloadDir": PAYLOAD_TEST_DIR,
}

var mockImplantHandshake = ImplantPacket{
    UUID:          "01010101010101010101010101010101",
    Key:           DUMMY_KEY,
    PacketType:    HANDSHAKE_REQ,
    PacketSize:    int64(PACKET_TYPE_SIZE + UUID_SIZE + DWORD_SIZE + (len("myHostName"))),
    PacketContent: []byte("\x0a\x00\x00\x00myHostName"),
}

var mockImplantXORHandshake = ImplantPacket{
    UUID:          "01010101010101010101010101010101",
    Key:           DUMMY_XOR_KEY,
    PacketType:    HANDSHAKE_REQ,
    PacketSize:    int64(PACKET_TYPE_SIZE + UUID_SIZE + DWORD_SIZE + (len("myHostName"))),
    PacketContent: []byte("\x0a\x00\x00\x00myHostName"),
}

var mockImplantSession = sessions.Session{
    GUID:     "ce03834430fcccbe541ccc5bf46cb1f2",
    IPAddr:   "127.0.0.1",
    HostName: "myHostName",
    Task:     nil,
}

var mockImplantHeartbeat = ImplantPacket{
    UUID:       "01010101010101010101010101010101",
    Key:        DUMMY_KEY,
    PacketType: BEACON,
    PacketSize: int64(17),
}

var mockImplantTaskInvalidOutput = ImplantPacket{
    UUID:          "01010101010101010101010101010101",
    Key:           DUMMY_KEY,
    PacketType:    TASK_OUTPUT,
    PacketSize:    int64(25),
    PacketContent: []byte{},
}

var mockImplantTaskInvalidType = ImplantPacket{
    UUID:          "01010101010101010101010101010101",
    Key:           DUMMY_KEY,
    PacketType:    IDLE,
    PacketSize:    int64(13),
    PacketContent: []byte{0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
}

var mockImplantFileChunkRequest1 = ImplantPacket{
    UUID:          "01010101010101010101010101010101",
    Key:           DUMMY_KEY,
    PacketType:    FILE_CHUNK_REQUEST,
    PacketSize:    int64(FILE_CHUNK_REQUEST_SIZE + PACKET_TYPE_SIZE + UUID_SIZE),
    PacketContent: []byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00},
}

var mockImplantFileChunkRequest2 = ImplantPacket{
    UUID:          "01010101010101010101010101010101",
    Key:           DUMMY_KEY,
    PacketType:    FILE_CHUNK_REQUEST,
    PacketSize:    int64(FILE_CHUNK_REQUEST_SIZE + PACKET_TYPE_SIZE + UUID_SIZE),
    PacketContent: []byte{0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00},
}

var mockImplantFileUploadChunk = ImplantPacket{
    UUID:          "01010101010101010101010101010101",
    Key:           DUMMY_KEY,
    PacketType:    TASK_OUTPUT,
    PacketSize:    int64(len(TEST_FILE_UPLOAD_CONTENTS) + PACKET_TYPE_SIZE + UUID_SIZE),
    PacketContent: []byte{0x01, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x74, 0x65, 0x73, 0x74, 0x20, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73},
}

// Generate example handler using the mock function wrappers
func generateMockToneshellHandler() *ToneshellHandler {
    mockFuncHandles := &WrappedFuncHandles{
        randStringGetter: handler_util.MockGetRandomAlphanumericString,
    }
    return ToneshellHandlerFactory(mockFuncHandles)
}

// Starts the RestAPI, generates the handler, and returns teardown function
func setupTest(t *testing.T) (*ToneshellHandler, func(t *testing.T)) {
    // Set up REST API server
    restapi_test_util.StartRestApiServer(t, "", REST_API_LISTEN_HOST, PAYLOAD_TEST_DIRS)

    // create and start mock handler
    handler := generateMockToneshellHandler()
    test_util.StartHandlerForUnitTest(t, handler, REST_API_LISTEN_HOST, testConfigEntry)

    return handler, func(t *testing.T) {
        restapi_test_util.StopRestApiServer()
        test_util.StopHandlerForUnitTest(t, handler)
    }
}

// Test getting tasks
func TestHandleGetTask(t *testing.T) {
    handler, teardownTest := setupTest(t)
    defer teardownTest(t)

    // Register session - must respond with beacon response
    resp, err := handler.HandleHandshake(mockImplantHandshake)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertDeepEq(t, resp, TEST_HANDSHAKE_RESPONSE, "")

    // Assign task
    _, err = handler_util.SetTask(REST_API_LISTEN_HOST, TEST_TASK, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }

    resp, err = handler.HandleGetTask(mockImplantHeartbeat, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertDeepEq(t, resp, TEST_TASK_RESPONSE, "")
}

// Test getting tasks with encryption
func TestHandleGetTaskEnc(t *testing.T) {
    handler, teardownTest := setupTest(t)
    defer teardownTest(t)

    handler.encType = C2_ENCRYPTION_RC4

    // Register session - must respond with beacon response
    resp, err := handler.HandleHandshake(mockImplantHandshake)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertDeepEq(t, resp, TEST_RC4_HANDSHAKE_RESPONSE, "")

    // Assign task
    _, err = handler_util.SetTask(REST_API_LISTEN_HOST, TEST_TASK, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }

    resp, err = handler.HandleGetTask(mockImplantHeartbeat, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertDeepEq(t, resp, TEST_RC4_TASK_RESPONSE, "")
}

func TestHandleGetResponse(t *testing.T) {
    handler, teardownTest := setupTest(t)
    defer teardownTest(t)

    // Register session and assign a task so we can send output
    resp, err := handler.HandleHandshake(mockImplantHandshake)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertDeepEq(t, resp, TEST_HANDSHAKE_RESPONSE, "")

    // Assign task
    _, err = handler_util.SetTask(REST_API_LISTEN_HOST, TEST_TASK, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }

    _, err = handler.HandleGetTask(mockImplantHeartbeat, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }

    // Test error condition: invalid packet length
    err = handler.HandleGetResponse(mockImplantTaskInvalidOutput, TEST_SESSION_ID)
    assert_util.AssertEq(t, err.Error(), "received task response with invalid length, dropping output", "expected error")

    // Test error condition: invalid packet type
    err = handler.HandleGetResponse(mockImplantTaskInvalidType, TEST_SESSION_ID)
    assert_util.AssertEq(t, err.Error(), "received task response with invalid packet type, dropping output", "expected error")
}

func TestHandleFileUpload(t *testing.T) {
    handler, teardownTest := setupTest(t)
    defer teardownTest(t)

    filePath := filepath.Join(util.UploadDir, TEST_FILE_UPLOAD_NAME)

    //remove the file if it already exists so we can get a fresh hash
    _ = os.Remove(filePath)

    // Test HandleFileUpload directly
    err := handler.HandleFileUpload(filePath, TEST_FILE_UPLOAD_CONTENTS)
    if err != nil {
        t.Fatal(err.Error())
    }
    handler.ClosePendingFileHandle(filePath)
    test_util.CheckUploadedFileHash(t, TEST_FILE_UPLOAD_NAME, TEST_UPLOAD_HASH)

    // Test HandleFileUpload via HandleGetResponse
    _ = os.Remove(filePath)
    resp, err := handler.HandleHandshake(mockImplantHandshake)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertDeepEq(t, resp, TEST_HANDSHAKE_RESPONSE, "")

    // Assign task
    _, err = handler_util.SetTask(REST_API_LISTEN_HOST, TEST_FILE_UPLOAD_TASK, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }

    _, err = handler.HandleGetTask(mockImplantHeartbeat, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }

    err = handler.HandleGetResponse(mockImplantFileUploadChunk, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }
    handler.ClosePendingFileHandle(filePath)
    test_util.CheckUploadedFileHash(t, TEST_FILE_UPLOAD_NAME, TEST_UPLOAD_HASH)
}

func TestHandleFileDownload(t *testing.T) {
    handler, teardownTest := setupTest(t)
    defer teardownTest(t)

    // Register session and assign a task so we can send output
    resp, err := handler.HandleHandshake(mockImplantHandshake)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertDeepEq(t, resp, TEST_HANDSHAKE_RESPONSE, "")

    // Assign task
    _, err = handler_util.SetTask(REST_API_LISTEN_HOST, TEST_FILE_DOWNLOAD_TASK, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }

    _, err = handler.HandleGetTask(mockImplantHeartbeat, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }

    // Send chunk requests and assert we get correct chunk sizes and values back
    resp, err = handler.HandleFileDownload(mockImplantFileChunkRequest1, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertDeepEq(t, resp, TEST_FILE_CHUNK_1, "")

    resp, err = handler.HandleFileDownload(mockImplantFileChunkRequest2, TEST_SESSION_ID)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertDeepEq(t, resp, TEST_FILE_CHUNK_2, "")
}

func TestParseImplantData(t *testing.T) {
    handler, teardownTest := setupTest(t)
    defer teardownTest(t)

    // Test valid implant packet
    resp, err := handler.ParseImplantPacket(TEST_HANDSHAKE_PACKET)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertEq(t, resp.UUID, mockImplantHandshake.UUID, "UUIDs do not match")
    assert_util.AssertDeepEq(t, resp.Key, mockImplantHandshake.Key, "Keys do not match")
    assert_util.AssertEq(t, resp.PacketType, mockImplantHandshake.PacketType, "Packet types do not match")
    assert_util.AssertEq(t, resp.PacketSize, mockImplantHandshake.PacketSize, "Packet sizes do not match")
    assert_util.AssertDeepEq(t, resp.PacketContent, mockImplantHandshake.PacketContent, "Packet contents do not match")

    // Test invalid implant packet
    _, err = handler.ParseImplantPacket(TEST_INVALID_PACKET)
    assert_util.AssertEq(t, err.Error(), "implant packet does not contain correct magic bytes, packet dropped", "expected error")
}

func TestParseEncImplantData(t *testing.T) {
    handler, teardownTest := setupTest(t)
    defer teardownTest(t)

    // Test RC4 enc
    handler.encType = C2_ENCRYPTION_RC4
    resp, err := handler.ParseImplantPacket(TEST_RC4_HANDSHAKE_PACKET)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertEq(t, resp.UUID, mockImplantHandshake.UUID, "UUIDs do not match")
    assert_util.AssertDeepEq(t, resp.Key, mockImplantHandshake.Key, "Keys do not match")
    assert_util.AssertEq(t, resp.PacketType, mockImplantHandshake.PacketType, "Packet types do not match")
    assert_util.AssertEq(t, resp.PacketSize, mockImplantHandshake.PacketSize, "Packet sizes do not match")
    assert_util.AssertDeepEq(t, resp.PacketContent, mockImplantHandshake.PacketContent, "Packet contents do not match")

    // Test XOR enc
    handler.encType = C2_ENCRYPTION_XOR
    resp, err = handler.ParseImplantPacket(TEST_XOR_HANDSHAKE_PACKET)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertEq(t, resp.UUID, mockImplantXORHandshake.UUID, "UUIDs do not match")
    assert_util.AssertDeepEq(t, resp.Key, mockImplantXORHandshake.Key, "Keys do not match")
    assert_util.AssertEq(t, resp.PacketType, mockImplantXORHandshake.PacketType, "Packet types do not match")
    assert_util.AssertEq(t, resp.PacketSize, mockImplantXORHandshake.PacketSize, "Packet sizes do not match")
    assert_util.AssertDeepEq(t, resp.PacketContent, mockImplantXORHandshake.PacketContent, "Packet contents do not match")
}

func TestXORCrypt(t *testing.T) {
    plaintext := "Hello world!"
    input := []byte(plaintext)
    XORCrypt(input, DUMMY_XOR_KEY)

    want := []byte{0x10, 0x2a, 0x3e, 0x27, 0x2a, 0x79, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21}
    assert_util.AssertDeepEq(t, input, want, "ciphertexts do not match")

    XORCrypt(input, DUMMY_XOR_KEY)
    assert_util.AssertDeepEq(t, input, []byte(plaintext), "decrypted plaintexts do not match")
}

func TestRC4Crypt(t *testing.T) {
    plaintext := "Hello world!"
    input := []byte(plaintext)
    err := RC4Crypt(input, DUMMY_KEY)
    if err != nil {
        t.Fatal(err.Error())
    }

    want := []byte{0x96, 0x7d, 0xe5, 0x2d, 0xcc, 0x17, 0x2a, 0x55, 0xf8, 0x6a, 0x7a, 0x46}
    assert_util.AssertDeepEq(t, input, want, "ciphertexts do not match")

    err = RC4Crypt(input, DUMMY_KEY)
    if err != nil {
        t.Fatal(err.Error())
    }
    assert_util.AssertDeepEq(t, input, []byte(plaintext), "decrypted plaintexts do not match")
}
